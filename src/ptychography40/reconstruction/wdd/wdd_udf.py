from typing import TYPE_CHECKING, Tuple, Optional, NamedTuple, List, Union, Dict

from libertem.common.buffers import BufferWrapper
import numpy as np
from libertem.udf import UDF
import numba

from ptychography40.stitching.stitching import stitch

from ptychography40.reconstruction.wdd import dim_reduct
from ptychography40.reconstruction.wdd.params_recon import WDDReconstructionPlan


if TYPE_CHECKING:
    import numpy.typing as nt


@numba.njit(fastmath=True, parallel=False)
def get_frame_contribution_to_cut_rowcol_exp(
    row_exp: np.ndarray,
    col_exp: np.ndarray,
    frame_compressed: np.ndarray,
    y: int,
    x: int,
    nav_shape: Tuple,
    wiener_filter_compressed: np.ndarray,
    scan_idx: np.ndarray,
    complex_dtype: 'nt.DTypeLike',
):

    """
    A Function to process data per frame and calculate the spatial frequency

    Parameters
    ----------
    row_exp
        Sampled Fourier basis on the row dimension
    col_exp
        Sampled Fourier basis on the column dimension
    frame_compressed
        Frame diffraction patterns after dimensionality reduction
    y
        Certain scanning point on y dimension
    x
        Certain scanning point on x dimension
    nav_shape
        Dimension of scanning points
    wiener_filter
        Four-dimensional Wiener filter after dimensionality reduction
    scan_idx
        Non zero contribution on the scanning points
    complex_dtype
        Pre defined complex dtype

    Returns
    -------
    cut
        Reconsruction of the specimen transfer function on Fourier space
        per scanning point

    """

    cut = np.zeros(nav_shape, dtype=complex_dtype)
    for nn_idx in range(len(scan_idx)):
        q = scan_idx[nn_idx][0]
        p = scan_idx[nn_idx][1]
        # assuming we have isotropic sampling,
        # np.allclose(row_exp, col_exp) holds:
        # If scan dim is not rectangular we cant use row_exp*row_exp!
        exp_factor = row_exp[y, q] * col_exp[x, p]
        acc = np.zeros((1), dtype=complex_dtype)[0]
        wiener_qp = wiener_filter_compressed[q, p]
        # NOTE: we still can cut this in ~half, as `
        # frame_compressed` should be truncated to
        # zero in the lower-right triangle
        for yy in range(frame_compressed.shape[0]):
            for xx in range(frame_compressed.shape[1]):
                acc += frame_compressed[yy, xx] * wiener_qp[yy, xx]
        cut[q, p] = (acc * exp_factor)
    return cut


def wdd_per_frame_combined(
    idp: np.ndarray,
    coeff: Tuple[np.ndarray, np.ndarray],
    wiener_filter_compressed: np.ndarray,
    scan_idx: np.ndarray,
    row_exp: np.ndarray,
    col_exp: np.ndarray,
    complex_dtype: 'nt.DTypeLike',
):
    """
    WDD in harmonic compressed space and process the data per frame

    Parameters
    ----------
    idp
        Intensity of diffraction patterns of 4D-STEM

    wiener_filter_compressed
        Four-dimensional compressed Wiener filter

    scan_idx
        Non-zero index position

    row_exp
        Sampled Fourier basis on the row dimension
    col_exp
        Sampled Fourier basis on the column dimension

    coeff
        Matrix from sampled Hermite-Gauss
        polynomials for both x and y direction
    complex_dtype
        Pre defined complex dtype
    """
    nav_shape = idp.shape[:2]
    cut = np.zeros((nav_shape[0], nav_shape[1]), dtype=complex_dtype)

    for y in range(nav_shape[0]):
        for x in range(nav_shape[1]):
            idp_compressed = dim_reduct.compress(idp[y, x], coeff)
            cut += get_frame_contribution_to_cut_rowcol_exp(
                row_exp, col_exp, idp_compressed, y, x, nav_shape,
                wiener_filter_compressed, scan_idx, complex_dtype,
            )
    real_cut = np.fft.ifft2((cut)).astype(complex_dtype)
    real_cut = real_cut/np.max(np.abs(real_cut))
    return real_cut.conj()


class WDDUDF(UDF):
    """
    Class that use UDF for live processing method,
    the implementation uses LiberTEM UDF

    Parameters
    ----------
    recon_parameters
        Reconstruction plan generated by :func:`ptychography40.reconstruction.wdd.\
            params_recon.wdd_params_recon`
    complex_dtype
        Complex dtype for array

    """

    def __init__(self, recon_parameters: WDDReconstructionPlan,
                 complex_dtype: "nt.DTypeLike" = np.complex64):
        super().__init__(
            recon_parameters=recon_parameters,
            complex_dtype=complex_dtype
        )

    def get_result_buffers(self):
        """
        Method for preparation of variable output

        """
        ds_shape = self.meta.dataset_shape
        patch_shape = self.params.recon_parameters.patch_shape
        if tuple(patch_shape) != tuple(ds_shape.nav):
            raise ValueError(
                f"Dataset nav shape {ds_shape.nav} doesn't match "
                f"reconstruction plan of shape {patch_shape}."
            )
        return {
            'cut': self.buffer(
                kind='single',
                extra_shape=self.meta.dataset_shape.nav,
                dtype=self.params.complex_dtype
            ),
            'reconstructed': self.buffer(
                kind='nav',
                use='result_only',
                dtype=self.params.complex_dtype
            ),
            'amplitude': self.buffer(
                kind='nav',
                use='result_only',
                dtype=np.float32,
            ),
            'phase': self.buffer(
                kind='nav',
                use='result_only',
                dtype=np.float32,
            ),
        }

    def process_frame(self, frame):

        """
        Method for processing frame per scan, since modification of WDD
        we can model the Fourier transformation into summation
        """
        y, x = self.meta.coordinates[0]
        frame_compressed = dim_reduct.compress(
            frame,
            self.params.recon_parameters.coeff)
        self.results.cut[:] += get_frame_contribution_to_cut_rowcol_exp(
            row_exp=self.params.recon_parameters.row_exp,
            col_exp=self.params.recon_parameters.col_exp,
            frame_compressed=frame_compressed,
            y=y,
            x=x,
            nav_shape=tuple(self.meta.dataset_shape.nav),
            wiener_filter_compressed=self.params.recon_parameters.wiener_filter_compressed,
            scan_idx=self.params.recon_parameters.wiener_roi,
            complex_dtype=self.params.complex_dtype
        )

    def merge(self, dest, src):
        """
        Merge result
        """
        dest.cut[:] += src.cut

    def get_results(self):
        """
        Inverse Fourier transform of the result in order to get into real space

        """
        real_cut = np.fft.ifft2(
            (self.results.cut)
            ).astype(self.params.complex_dtype)
        real_cut = real_cut/np.max(np.abs(real_cut))
        res = real_cut.conj()
        return {
            'cut': self.results.cut,
            'reconstructed': res,
            # for live plotting
            'amplitude': np.abs(res),
            'phase': np.angle(res),
        }


class PatchIndex(NamedTuple):
    '''
    Specify patch index and index within that patch
    '''
    patch_index: int
    within_patch: int


class GridSpec:
    '''
    Index calculations in a set of overlapping patches

    Parameters
    ----------

    size
        patch size
    step
        patch step, distance between patches
    '''
    def __init__(self, size: int, step: int):
        if not isinstance(size, int):
            raise ValueError(f"Size {size} must be integer")
        if not isinstance(step, int):
            raise ValueError(f"Step {step} must be integer")
        if size < step:
            raise ValueError(f"Size {size} < step {step}, has gap!")
        if size <= 0:
            raise ValueError(f"Size {size} must be positive")
        if step <= 0:
            raise ValueError(f"Step {step} must be positive")
        self.size = size
        self.step = step

    def get_patch_indices(self, coord) -> List[PatchIndex]:
        '''
        Get all patch indices and indices within these patches that overlap
        with the given coordinate.

        Parameters
        ----------

        coord
           coordinate to calculate indices for
        '''
        res = []
        patch_index = coord // self.step
        while patch_index * self.step + self.size > coord:
            within_patch = coord - patch_index * self.step
            res.append(PatchIndex(patch_index=patch_index, within_patch=within_patch))
            patch_index -= 1
        return res

    @property
    def min_patch_index(self):
        '''
        Calculate the smallest tile index that overlaps with the 0 coordinate

        Typically 0 or a negative number
        '''
        candidates = self.get_patch_indices(0)
        assert len(candidates) > 0
        min_index = min(c.path_index for c in candidates)
        return min_index

    def max_patch_index(self, size):
        '''
        Calculate the largest tile index that is necessary to accommodate an
        array of the given size.
        '''
        return (size - 1) // self.step


class PatchWDDUDF(UDF):
    """
    Reconstruct many small patches with WDD and merge them in the end

    This approach allows much better [O(N)?] scaling for large reconstruction
    areas. The method is experimental and not fully validated.

    The size of reconstruction patches is defined by the pre-computed
    reconstruction data structure :code:`recon_parameters` generated by
    :func:`ptychography40.reconstruction.wdd.params_recon.wdd_params_recon`.
    This function offers an optional :code:`patch_shape` parameter to specify a
    reconstruction patch shape that is different from the dataset nav dimension.

    The border region of patches exhibits strong deviations because it is a
    step-wise discontinuity in the periodic boundary condition of WDD where WDD
    doesn't allow transfer of all required spatial freqencies. For that reason,
    the border region of patches is trimmed on all sides, this is specified as
    :code:`patch_trim`.

    Furthermore, the individual patches have a different phase offset since WDD
    doesn't reconstruct an absolute phase. Therefore the individual patches are
    combined using :func:`ptychography40.stitching.stitching.stitch`, which
    minimizes the phase difference and then averages. This requires some
    overlap, which is specified with :code:`patch_overlap`. Larger overlap
    further reduces edge effects.

    Consequently, the step from patch to patch is determined so that the desired
    overlap is achieved after the trim is removed.

    Visual example in one dimension:

    | :code:`patch_shape == 11`
    | :code:`patch_trim == 3`
    | :code:`patch_overlap == 2`
    | Resulting :code:`patch_step`: :code:`3 == patch_shape - 2*patch_trim -
      patch_overlap`

    The asterisks indicates the trimmed part of the patches.

    ::

        ***#####***      Patch 1
              ||         Patch overlap
        ...***#####***   Patch 2, shifted by 3x .


    Parameters
    ----------
    recon_parameters
        Reconstruction plan generated by
        :func:`ptychography40.reconstruction.wdd.params_recon.wdd_params_recon`
    patch_overlap
        (y, x) overlap of reconstruction patches after subtracting trim, default
        is eight
    patch_trim
        Remove border pixels of patches to suppress edge effects, default eight
        pixels
    complex_dtype
        Complex dtype for array

    """

    def __init__(self, recon_parameters: WDDReconstructionPlan,
                 patch_overlap: Optional[Union[Tuple[int, int], int]] = None,
                 patch_trim: Optional[Union[Tuple[int, int], int]] = None,
                 complex_dtype: "nt.DTypeLike" = np.complex64):
        patch_y, patch_x = recon_parameters.patch_shape
        if patch_trim is None:
            patch_trim = (8, 8)
        elif isinstance(patch_trim, int):
            patch_trim = (patch_trim, patch_trim)
        if patch_overlap is None:
            patch_overlap = (8, 8)
        elif isinstance(patch_overlap, int):
            patch_overlap = (patch_overlap, patch_overlap)

        patch_step = self._calc_patch_step(
            patch_shape=(patch_y, patch_x),
            patch_trim=patch_trim,
            patch_overlap=patch_overlap
        )

        if patch_step[0] <= 0 or patch_step[1] <= 0:
            raise ValueError(
                f"Patch step {patch_step} <= 0, patch overlap {patch_overlap} and"
                F"patch trim {patch_trim} are too large for patch size ({patch_y, patch_x}).")
        super().__init__(
            recon_parameters=recon_parameters,
            patch_overlap=patch_overlap,
            patch_trim=patch_trim,
            complex_dtype=complex_dtype
        )

    @staticmethod
    def _calc_patch_step(patch_shape, patch_trim, patch_overlap):
        return (
            patch_shape[0] - 2*patch_trim[0] - patch_overlap[0],
            patch_shape[1] - 2*patch_trim[1] - patch_overlap[1]
        )

    @property
    def patch_step(self):
        return self._calc_patch_step(
            patch_shape=self.patch_shape,
            patch_trim=self.params.patch_trim,
            patch_overlap=self.params.patch_overlap
        )

    @property
    def patch_shape(self):
        'Shorthand'
        return self.params.recon_parameters.patch_shape

    @property
    def gridspec(self):
        patch_shape = self.patch_shape
        patch_step = self.patch_step
        y_grid = GridSpec(step=patch_step[0], size=patch_shape[0])
        x_grid = GridSpec(step=patch_step[1], size=patch_shape[1])
        return (y_grid, x_grid)

    @property
    def patch_offset(self):
        (y_grid, x_grid) = self.gridspec
        return (-y_grid.min_patch_index, -x_grid.min_patch_index)

    def get_result_buffers(self) -> Dict[str, BufferWrapper]:
        ds_nav = self.meta.dataset_shape.nav
        (y_grid, x_grid) = self.gridspec
        y_offset, x_offset = self.patch_offset
        y_count = y_grid.max_patch_index(ds_nav[0]) + y_offset + 1
        x_count = x_grid.max_patch_index(ds_nav[1]) + x_offset + 1
        cuts_shape = (y_count, x_count, *self.patch_shape)
        return {
            'cuts': self.buffer(
                kind='single',
                extra_shape=cuts_shape,
                dtype=self.params.complex_dtype
            ),
            'reconstructed': self.buffer(
                kind='nav',
                use='result_only',
                dtype=self.params.complex_dtype
            ),
            # for live plotting
            'amplitude': self.buffer(
                kind='nav',
                use='result_only',
                dtype=np.float32,
            ),
            'phase': self.buffer(
                kind='nav',
                use='result_only',
                dtype=np.float32,
            ),
        }

    def process_frame(self, frame):
        """
        Method for processing frame per scan, since modification of WDD
        we can model the Fourier transformation into summation
        """
        y, x = self.meta.coordinates[0]
        frame_compressed = dim_reduct.compress(
            frame,
            self.params.recon_parameters.coeff)
        y_grid, x_grid = self.gridspec
        y_steps = y_grid.get_patch_indices(y)
        x_steps = x_grid.get_patch_indices(x)
        y_offset, x_offset = self.patch_offset
        for y_step in y_steps:
            for x_step in x_steps:
                y_patch = y_step.patch_index + y_offset
                x_patch = x_step.patch_index + x_offset
                y_coord = y_step.within_patch
                x_coord = x_step.within_patch
                self.results.cuts[y_patch, x_patch] += get_frame_contribution_to_cut_rowcol_exp(
                    row_exp=self.params.recon_parameters.row_exp,
                    col_exp=self.params.recon_parameters.col_exp,
                    frame_compressed=frame_compressed,
                    y=y_coord,
                    x=x_coord,
                    nav_shape=self.patch_shape,
                    wiener_filter_compressed=self.params.recon_parameters.wiener_filter_compressed,
                    scan_idx=self.params.recon_parameters.wiener_roi,
                    complex_dtype=self.params.complex_dtype
                )

    def merge(self, dest, src):
        """
        Merge result
        """
        dest.cuts[:] += src.cuts

    def get_results(self):
        """
        Inverse Fourier transform of the result in order to get into real space

        """
        layers = []
        rec_shape = tuple(self.meta.dataset_shape.nav)
        gsp = self.gridspec
        y_start_padding = -gsp[0].min_patch_index * gsp[0].step
        x_start_padding = -gsp[1].min_patch_index * gsp[1].step
        y_stop_padding = (
            gsp[0].max_patch_index(rec_shape[0]) * gsp[0].step
            + gsp[0].size
            - rec_shape[0]
        )
        x_stop_padding = (
            gsp[1].max_patch_index(rec_shape[1]) * gsp[1].step
            + gsp[1].size
            - rec_shape[1]
        )
        layer_shape = (
            rec_shape[0] + y_start_padding + y_stop_padding,
            rec_shape[1] + x_start_padding + x_stop_padding
        )
        zero_pad = np.ones(self.patch_shape)
        y_trim, x_trim = self.params.patch_trim
        zero_pad[0:y_trim, :] = 0
        zero_pad[-y_trim:, :] = 0
        zero_pad[:, 0:x_trim] = 0
        zero_pad[:, -x_trim:] = 0
        for y_patch in range(self.results.cuts.shape[0]):
            for x_patch in range(self.results.cuts.shape[1]):
                cut = self.results.cuts[y_patch, x_patch]
                # Skip empty cuts
                if np.any(cut != 0):
                    real_cut = np.fft.ifft2(
                        (cut)
                        ).astype(self.params.complex_dtype)
                    real_cut *= zero_pad
                    layers.append((y_patch, x_patch, real_cut))
        if layers:
            result_stack = np.zeros(
                shape=layer_shape + (len(layers), ),
                dtype=self.params.complex_dtype
            )
            for i, (y_patch, x_patch, layer) in enumerate(layers):
                y_start = y_patch * gsp[0].step
                x_start = x_patch * gsp[1].step
                y_stop = y_start + gsp[0].size
                x_stop = x_start + gsp[1].size
                result_stack[y_start:y_stop, x_start:x_stop, i] = layer
            res = stitch(result_stack)[
                y_start_padding:-y_stop_padding,
                x_start_padding:-x_stop_padding
            ]
            assert res.shape == rec_shape
            res /= np.max(np.abs(res))
        else:
            # Empty result
            res = np.zeros(rec_shape, dtype=self.params.complex_dtype)
        res = res.conj()
        return {
            'cuts': self.results.cuts,
            'reconstructed': res,
            'amplitude': np.abs(res),
            'phase': np.angle(res),
        }
